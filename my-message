Write code to perform the following steps:
Read an image file. Some sample code to show how you might do this is here: Sample Java Code.
Print statistics on the image: filename, number of pixels in the file, image height, and image width. (see the sample code)
Input another file containing an ascii text message and generate a new image that is visually identical to the original image, but contains the hidden message. If the original was in a file named "xxxx.ext" the new file should be called "xxxx-steg.ext" That is, preserve the file extension, if any.
Your code also should be able to extract the message from a modified image. Specify an output file name on the command line.
Names of both the image file and message file should be passed on the command line. Additionally, a flag should be used to indicate whether you are encoding or decoding. For example, consider the following commands.
Steganography -E image.png my-message
Steganography -D image-steg.png my-message-out
The first indicates encoding the contents of the ascii file my-message into the image in image.png. This should produce an image file named image-steg.png. The second line takes the modified image and extracts the hidden message. It puts it into a file called my-message-out.
Hiding the Message:

Each pixel in the image is represented by 24 bits of information. You can extract each of the RGB values from the pixel and store one bit of information in each. For example, suppose the pixel has RGB values of (126, 240, 122), and the next three bits you'd like to store are 1, 1, 0. The encoding scheme is as follows: If the bit you want to store is 0, make the corresponding byte even; if the bit is 1, make the byte odd. For example, the RGB triple above might store (1, 1, 0) by becoming (127, 241, 122). (On average, only half of the RGB values will change need to change, further reducing the visible effects.) Reading the bits is merely reading the even/odd-ness of successive RGB values. When you do change the parity, it doesn't seem important whether you raise or lower the value. But be careful not to decrement 0 or increment 255, as these may cause an error or make a much more visible change to the pixel. Notice also that, given this scheme, it may not be possible to recover the original image exactly from the modified image.
Using this approach you can store the message in the image using 3 bits per pixel. Store a 0 byte to indicate the end of the message. If your input message is too long to store in the given image, you should store as much as you can. But be sure to allow enough room to store the final 0 byte; also print an error message to the terminal indicating that you've truncated the message. (Recall that you've already computed the number of pixels, so know how many bits of message the image can store.) I came up with this method off the top of my head. I don't see any reason why it shouldn't work; but please let me know if you do.

In your README file, you should address the following:

Comparing your original and modified images carefully, can you detect *any* difference visually (that is, in the appearance of the image)?
Can you think of other ways you might hide the message in image files (or in other types of files)?
Can you invent ways to increase the bandwidth of the channel?
Suppose you were tasked to build an "image firewall" that would block images containing hidden messages. Could you do it? How might you approach this problem?
Does this fit our definition of a covert channel? Explain your answer.